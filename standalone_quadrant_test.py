#!/usr/bin/env python3
"""
Standalone Quadrant Test

Simple test to verify quadrant-based buffer mapping works.
Place this file in your main project directory (same level as core/ folder).
"""

import sys
import os
import time

# Add current directory to path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Import your existing core
try:
    from core.core import working_core, clear
    print("‚úÖ Successfully imported working_core")
except ImportError as e:
    print(f"‚ùå Could not import core: {e}")
    print("Make sure this file is in the same directory as your core/ folder")
    sys.exit(1)

def create_bitmap_from_pattern(pattern):
    """Convert a visual pattern into bytes for double-height display."""
    if len(pattern) != 14:
        raise ValueError("Pattern must be exactly 14 rows")
    
    width = len(pattern[0]) if pattern else 0
    top_bytes = []
    bottom_bytes = []
    
    for col in range(width):
        top_byte = 0
        bottom_byte = 0
        
        # Top 7 rows (0-6)
        for row in range(7):
            if row < len(pattern) and col < len(pattern[row]):
                if pattern[row][col] == '#':
                    top_byte |= (1 << (6 - row))
        
        # Bottom 7 rows (7-13)
        for row in range(7, 14):
            if row < len(pattern) and col < len(pattern[row]):
                if pattern[row][col] == '#':
                    bottom_byte |= (1 << (13 - row))
        
        top_bytes.append(top_byte)
        bottom_bytes.append(bottom_byte)
    
    return bytes(top_bytes), bytes(bottom_bytes)

def display_double_height_quadrant(top_bytes, bottom_bytes):
    """
    Display double-height character using QUADRANT-based buffer mapping.
    
    Your display mapping:
    - Bytes 0-15: Upper left quadrant
    - Bytes 15-30: Upper right quadrant  
    - Bytes 30-45: Lower left quadrant
    - Bytes 45-60: Lower right quadrant
    """
    print(f"Input: top_bytes={list(top_bytes)}, bottom_bytes={list(bottom_bytes)}")
    
    # Use your proven position 103 for horizontal positioning
    padded_top = b'\x00' * 105 + top_bytes + b'\x00' * 105  
    padded_bottom = b'\x00' * 105 + bottom_bytes + b'\x00' * 105
    
    top_chunk = padded_top[103:103 + 105]
    bottom_chunk = padded_bottom[103:103 + 105] 
    
    print(f"After position 103: top_chunk length={len(top_chunk)}, bottom_chunk length={len(bottom_chunk)}")
    
    # Create 105-byte buffer
    quadrant_buffer = [0] * 105
    
    # Map top row to upper quadrants (0-15 and 15-30)
    top_pixels = 0
    for i in range(min(30, len(top_chunk))):
        if top_chunk[i] != 0:
            top_pixels += 1
        if i < 15:
            # Upper left quadrant (bytes 0-14)
            quadrant_buffer[i] = top_chunk[i]
        else:
            # Upper right quadrant (bytes 15-29) 
            quadrant_buffer[i] = top_chunk[i]
    
    # Map bottom row to lower quadrants (30-45 and 45-60)
    bottom_pixels = 0
    for i in range(min(30, len(bottom_chunk))):
        if bottom_chunk[i] != 0:
            bottom_pixels += 1
        if i < 15:
            # Lower left quadrant (bytes 30-44)
            quadrant_buffer[30 + i] = bottom_chunk[i]
        else:
            # Lower right quadrant (bytes 45-59)
            quadrant_buffer[30 + i] = bottom_chunk[i]
    
    print(f"Buffer stats: top_pixels={top_pixels}, bottom_pixels={bottom_pixels}")
    print(f"Non-zero positions in buffer:")
    for i, byte in enumerate(quadrant_buffer):
        if byte != 0:
            print(f"  Position {i}: {byte} (0b{byte:07b})")
    
    # Display it
    working_core.fill(bytes(quadrant_buffer))

# Simple test patterns
TEST_PATTERNS = {
    'I': [
        '######',  # 0 - Top bar
        '  ##  ',  # 1 - Stem
        '  ##  ',  # 2 - Stem  
        '  ##  ',  # 3 - Stem
        '  ##  ',  # 4 - Stem
        '  ##  ',  # 5 - Stem
        '  ##  ',  # 6 - Stem
        '  ##  ',  # 7 - Stem
        '  ##  ',  # 8 - Stem
        '  ##  ',  # 9 - Stem
        '  ##  ',  # 10 - Stem
        '######',  # 11 - Bottom bar
        '      ',  # 12
        '      '   # 13
    ],
    'A': [
        '  ##  ',  # 0
        ' #  # ',  # 1  
        '#    #',  # 2
        '#    #',  # 3
        '#    #',  # 4
        '######',  # 5
        '#    #',  # 6
        '#    #',  # 7
        '#    #',  # 8
        '#    #',  # 9
        '#    #',  # 10
        '#    #',  # 11
        '      ',  # 12
        '      '   # 13
    ]
}

def test_simple_patterns():
    """Test simple patterns with quadrant mapping."""
    print("üß™ Testing Simple Patterns with Quadrant Mapping")
    print("=" * 60)
    
    for char, pattern in TEST_PATTERNS.items():
        print(f"\nTesting character: '{char}'")
        print("Pattern preview:")
        for i, row in enumerate(pattern):
            print(f"  {i:2d}: {row}")
        
        # Convert to bytes
        top_bytes, bottom_bytes = create_bitmap_from_pattern(pattern)
        print(f"\nGenerated bytes:")
        print(f"Top bytes: {list(top_bytes)}")
        print(f"Bottom bytes: {list(bottom_bytes)}")
        
        choice = input(f"\nDisplay '{char}' with quadrant mapping? (y/n): ").strip().lower()
        if choice == 'y':
            display_double_height_quadrant(top_bytes, bottom_bytes)
            result = input("Result: (g)ood, (p)artial, (b)ad: ").strip().lower()
            clear()
            
            if result == 'g':
                print(f"‚úÖ '{char}' looks complete!")
            elif result == 'p':
                print(f"‚ö†Ô∏è '{char}' partially visible")
            else:
                print(f"‚ùå '{char}' not working")

def test_buffer_mapping_systematically():
    """Test different buffer mapping approaches."""
    print("üî¨ Testing Buffer Mapping Systematically")
    print("=" * 50)
    
    # Create simple test pattern - just a vertical line
    test_top = bytes([0b1111111, 0b0000000])    # One full column + space
    test_bottom = bytes([0b1111111, 0b0000000])  # Same for bottom
    
    print("Test pattern: One vertical line spanning full height")
    print("This should create a tall line from top to bottom of display")
    
    mapping_strategies = [
        ("Original +75 offset", test_offset_75),
        ("Quadrant mapping", test_quadrant_mapping_strategy),
        ("Simple row mapping", test_simple_row_mapping),
    ]
    
    for name, test_func in mapping_strategies:
        choice = input(f"\nTry {name}? (y/n): ").strip().lower()
        if choice == 'y':
            print(f"Testing: {name}")
            test_func(test_top, test_bottom)
            result = input("Result: (g)ood - see full line, (p)artial - see top only, (b)ad - see nothing: ").strip().lower()
            clear()
            
            if result == 'g':
                print(f"‚úÖ {name} works!")
                return name
            elif result == 'p':
                print(f"‚ö†Ô∏è {name} shows top only")
            else:
                print(f"‚ùå {name} doesn't work")
    
    return None

def test_offset_75(test_top, test_bottom):
    """Test original +75 offset approach."""
    padded_top = b'\x00' * 105 + test_top + b'\x00' * 105  
    padded_bottom = b'\x00' * 105 + test_bottom + b'\x00' * 105
    
    top_chunk = padded_top[103:103 + 105]
    bottom_chunk = padded_bottom[103:103 + 105] 
    
    buffer = list(top_chunk)
    for i, byte in enumerate(bottom_chunk):
        if i + 75 < 105:
            buffer[i + 75] = byte
    
    working_core.fill(bytes(buffer))

def test_quadrant_mapping_strategy(test_top, test_bottom):
    """Test quadrant mapping approach."""
    display_double_height_quadrant(test_top, test_bottom)

def test_simple_row_mapping(test_top, test_bottom):
    """Test simple row mapping (+30 offset)."""
    padded_top = b'\x00' * 105 + test_top + b'\x00' * 105  
    padded_bottom = b'\x00' * 105 + test_bottom + b'\x00' * 105
    
    top_chunk = padded_top[103:103 + 105]
    bottom_chunk = padded_bottom[103:103 + 105] 
    
    buffer = list(top_chunk)
    for i, byte in enumerate(bottom_chunk):
        if i + 30 < 105:
            buffer[i + 30] = byte
    
    working_core.fill(bytes(buffer))

if __name__ == "__main__":
    print("üéØ Standalone Quadrant Mapping Test")
    print("=" * 50)
    print("This test helps determine the correct buffer mapping for your display.")
    
    choice = input("\nTest simple patterns first? (y/n): ").strip().lower()
    if choice == 'y':
        test_simple_patterns()
    
    choice = input("\nTest buffer mapping systematically? (y/n): ").strip().lower()
    if choice == 'y':
        working_strategy = test_buffer_mapping_systematically()
        if working_strategy:
            print(f"\nüéâ Found working strategy: {working_strategy}")
    
    print("\n‚úÖ Standalone test complete!")
    print("Once we find the working buffer mapping, we can update the full system.")
